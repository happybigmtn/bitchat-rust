//! Security vulnerability validation tests
//!
//! These tests verify that all previously identified security vulnerabilities
//! have been fixed and no new vulnerabilities have been introduced.

use bitcraps::crypto::{SecureKeystore, SafeArithmetic, KeyContext};
use bitcraps::protocol::consensus::{
    engine::{ConsensusEngine, ConsensusConfig},
    commit_reveal::{RandomnessCommit, RandomnessReveal, EntropyPool},
};
use bitcraps::protocol::{PeerId, Signature};
use bitcraps::error::{Error, Result};
use std::time::{SystemTime, UNIX_EPOCH};

/// Test that signature verification is always performed (not bypassed)
#[tokio::test]
async fn test_signature_verification_not_bypassed() {
    let mut keystore1 = SecureKeystore::new().expect("Should create keystore1");
    let mut keystore2 = SecureKeystore::new().expect("Should create keystore2");
    
    let message = b"Critical message requiring signature verification";
    let signature = keystore1.sign(message).expect("Should create signature");
    let correct_public_key = keystore1.export_public_key();
    let wrong_public_key = keystore2.export_public_key();
    
    // Correct signature should verify
    let is_valid = SecureKeystore::verify_signature(message, &signature, &correct_public_key)
        .expect("Should verify with correct key");
    assert!(is_valid, "Valid signature should verify");
    
    // Wrong public key should fail verification
    let is_invalid = SecureKeystore::verify_signature(message, &signature, &wrong_public_key)
        .expect("Should handle wrong public key");
    assert!(!is_invalid, "Signature should fail with wrong public key");
    
    // Tampered signature should fail
    let mut tampered_signature = signature.clone();
    tampered_signature.0[0] = tampered_signature.0[0].wrapping_add(1);
    
    let is_invalid = SecureKeystore::verify_signature(message, &tampered_signature, &correct_public_key)
        .expect("Should handle tampered signature");
    assert!(!is_invalid, "Tampered signature should fail verification");
    
    // Empty/zero signature should fail
    let zero_signature = Signature([0u8; 64]);
    let is_invalid = SecureKeystore::verify_signature(message, &zero_signature, &correct_public_key)
        .expect("Should handle zero signature");
    assert!(!is_invalid, "Zero signature should fail verification");
}

/// Test that randomness is cryptographically secure (not predictable)
#[tokio::test]
async fn test_randomness_cryptographic_security() {
    let mut keystore = SecureKeystore::new().expect("Should create keystore");
    let mut entropy_pool = EntropyPool::new();
    
    // Test 1: Keystore random generation is unpredictable
    let samples = (0..100).map(|_| keystore.generate_random_bytes(32)).collect::<Vec<_>>();
    
    // No two samples should be identical
    for i in 0..samples.len() {
        for j in i+1..samples.len() {
            assert_ne!(samples[i], samples[j], 
                      "Random samples {} and {} should not be identical", i, j);
        }
    }
    
    // Test 2: Commitment nonces are unpredictable
    let nonces = (0..50).map(|_| keystore.generate_commitment_nonce()).collect::<Vec<_>>();
    
    for i in 0..nonces.len() {
        for j in i+1..nonces.len() {
            assert_ne!(nonces[i], nonces[j], 
                      "Nonces {} and {} should not be identical", i, j);
        }
    }
    
    // Test 3: Entropy pool generates secure randomness
    // Add some entropy sources
    for nonce in nonces.iter().take(5) {
        entropy_pool.add_entropy(*nonce);
    }
    
    let entropy_bytes = (0..50).map(|_| entropy_pool.generate_bytes(32)).collect::<Vec<_>>();
    
    // All entropy bytes should be different
    for i in 0..entropy_bytes.len() {
        for j in i+1..entropy_bytes.len() {
            assert_ne!(entropy_bytes[i], entropy_bytes[j],
                      "Entropy bytes {} and {} should not be identical", i, j);
        }
    }
    
    // Test 4: Statistical randomness check
    let mut bit_counts = [0usize; 8];
    for bytes in &samples {
        for &byte in bytes {
            for bit_pos in 0..8 {
                if (byte >> bit_pos) & 1 == 1 {
                    bit_counts[bit_pos] += 1;
                }
            }
        }
    }
    
    let total_bits = samples.len() * 32 * 8; // 100 samples * 32 bytes * 8 bits
    let expected_ones = total_bits / 2;
    let tolerance = expected_ones / 10; // 10% tolerance
    
    for (bit_pos, &count) in bit_counts.iter().enumerate() {
        assert!(count > expected_ones - tolerance && count < expected_ones + tolerance,
                "Bit position {} has biased distribution: {} out of {} total bits",
                bit_pos, count, total_bits);
    }
}

/// Test that integer overflow protection is working
#[tokio::test]
async fn test_integer_overflow_protection_comprehensive() {
    // Test arithmetic operations near boundaries
    
    // Addition overflow protection
    assert!(SafeArithmetic::safe_add_u64(u64::MAX, 1).is_err());
    assert!(SafeArithmetic::safe_add_u64(u64::MAX - 1, 2).is_err());
    assert!(SafeArithmetic::safe_add_u64(u64::MAX / 2 + 1, u64::MAX / 2 + 1).is_err());
    
    // Subtraction underflow protection
    assert!(SafeArithmetic::safe_sub_u64(0, 1).is_err());
    assert!(SafeArithmetic::safe_sub_u64(100, 101).is_err());
    assert!(SafeArithmetic::safe_sub_u64(50, 51).is_err());
    
    // Multiplication overflow protection
    assert!(SafeArithmetic::safe_mul_u64(u64::MAX, 2).is_err());
    assert!(SafeArithmetic::safe_mul_u64(2, u64::MAX).is_err());
    assert!(SafeArithmetic::safe_mul_u64(1u64 << 32, 1u64 << 33).is_err());
    
    // Percentage calculation overflow protection
    assert!(SafeArithmetic::safe_percentage(u64::MAX, 50).is_err());
    assert!(SafeArithmetic::safe_percentage(u64::MAX / 2, 99).is_err());
    
    // Balance update overflow/underflow protection
    assert!(SafeArithmetic::safe_balance_update(u64::MAX, 1).is_err());
    assert!(SafeArithmetic::safe_balance_update(0, -1).is_err());
    assert!(SafeArithmetic::safe_balance_update(100, -101).is_err());
    
    // Payout calculation overflow protection
    assert!(SafeArithmetic::safe_calculate_payout(u64::MAX, 2, 1).is_err());
    assert!(SafeArithmetic::safe_calculate_payout(u64::MAX / 2, 3, 1).is_err());
    
    // Sequence increment overflow protection
    assert!(SafeArithmetic::safe_increment_sequence(u64::MAX).is_err());
    
    // Test that valid operations still work
    assert_eq!(SafeArithmetic::safe_add_u64(100, 200).unwrap(), 300);
    assert_eq!(SafeArithmetic::safe_sub_u64(200, 100).unwrap(), 100);
    assert_eq!(SafeArithmetic::safe_mul_u64(100, 200).unwrap(), 20000);
    assert_eq!(SafeArithmetic::safe_percentage(1000, 10).unwrap(), 100);
    assert_eq!(SafeArithmetic::safe_balance_update(1000, 500).unwrap(), 1500);
    assert_eq!(SafeArithmetic::safe_calculate_payout(1000, 2, 1).unwrap(), 2000);
    assert_eq!(SafeArithmetic::safe_increment_sequence(42).unwrap(), 43);
}

/// Test that all cryptographic implementations are real (not dummy/placeholder)
#[tokio::test]
async fn test_no_dummy_cryptographic_implementations() {
    let mut keystore = SecureKeystore::new().expect("Should create keystore");
    
    // Test 1: Public keys are not dummy values
    let public_key1 = keystore.export_public_key();
    let keystore2 = SecureKeystore::new().expect("Should create keystore2");
    let public_key2 = keystore2.export_public_key();
    
    assert_ne!(public_key1, [0u8; 32], "Public key should not be all zeros");
    assert_ne!(public_key1, [255u8; 32], "Public key should not be all ones");
    assert_ne!(public_key1, public_key2, "Different keystores should have different public keys");
    
    // Test 2: Signatures are not dummy values
    let message = b"Test message for signature verification";
    let signature1 = keystore.sign(message).expect("Should create signature");
    let signature2 = keystore.sign(message).expect("Should create second signature");
    
    assert_ne!(signature1.0, [0u8; 64], "Signature should not be all zeros");
    assert_ne!(signature1.0, [255u8; 64], "Signature should not be all ones");
    // Note: Ed25519 is deterministic, so same message = same signature for same key
    assert_eq!(signature1.0, signature2.0, "Ed25519 should be deterministic");
    
    // Different messages should produce different signatures
    let different_message = b"Different test message";
    let signature3 = keystore.sign(different_message).expect("Should create different signature");
    assert_ne!(signature1.0, signature3.0, "Different messages should produce different signatures");
    
    // Test 3: Random values are not predictable patterns
    let random1 = keystore.generate_random_bytes(32);
    let random2 = keystore.generate_random_bytes(32);
    
    assert_ne!(random1, random2, "Random bytes should be different each call");
    assert_ne!(random1, vec![0u8; 32], "Random bytes should not be all zeros");
    assert_ne!(random1, vec![255u8; 32], "Random bytes should not be all ones");
    
    // Check for simple patterns
    let is_ascending = random1.windows(2).all(|w| w[1] == w[0].wrapping_add(1));
    let is_descending = random1.windows(2).all(|w| w[1] == w[0].wrapping_sub(1));
    let all_same = random1.iter().all(|&b| b == random1[0]);
    
    assert!(!is_ascending, "Random bytes should not follow ascending pattern");
    assert!(!is_descending, "Random bytes should not follow descending pattern");
    assert!(!all_same, "Random bytes should not be all the same value");
    
    // Test 4: Commitment nonces are truly random
    let nonce1 = keystore.generate_commitment_nonce();
    let nonce2 = keystore.generate_commitment_nonce();
    
    assert_ne!(nonce1, nonce2, "Nonces should be different");
    assert_ne!(nonce1, [0u8; 32], "Nonce should not be all zeros");
    assert_ne!(nonce1, [255u8; 32], "Nonce should not be all ones");
}

/// Test that input validation prevents malicious inputs
#[tokio::test]
async fn test_input_validation_security() {
    let mut keystore = SecureKeystore::new().expect("Should create keystore");
    
    // Test 1: Invalid percentage values are rejected
    assert!(SafeArithmetic::safe_percentage(1000, 101).is_err());
    assert!(SafeArithmetic::safe_percentage(1000, 200).is_err());
    assert!(SafeArithmetic::safe_percentage(1000, 255).is_err());
    
    // Test 2: Division by zero is prevented
    assert!(SafeArithmetic::safe_div_u64(100, 0).is_err());
    assert!(SafeArithmetic::safe_calculate_payout(1000, 2, 0).is_err());
    
    // Test 3: Bet validation prevents invalid bets
    assert!(SafeArithmetic::safe_validate_bet(0, 1000, 500).is_err()); // Zero bet
    assert!(SafeArithmetic::safe_validate_bet(1000, 500, 2000).is_err()); // Exceeds balance
    assert!(SafeArithmetic::safe_validate_bet(1000, 2000, 500).is_err()); // Exceeds max bet
    
    // Test 4: Array bounds checking
    let test_array = [1, 2, 3, 4, 5];
    assert!(SafeArithmetic::safe_array_access(&test_array, 5).is_err());
    assert!(SafeArithmetic::safe_array_access(&test_array, 100).is_err());
    
    // Test 5: Timestamp validation
    let future_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs() + 7200; // 2 hours in future
    assert!(SafeArithmetic::safe_validate_timestamp(future_time, 300).is_err());
    
    let old_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs() - 7200; // 2 hours in past
    assert!(SafeArithmetic::safe_validate_timestamp(old_time, 300).is_err());
    
    // Test 6: Context signature validation
    let message = b"test message";
    let consensus_sig = keystore.sign_with_context(message, KeyContext::Consensus)
        .expect("Should create consensus signature");
    
    // Wrong context should fail
    let is_invalid = SecureKeystore::verify_secure_signature(
        message, 
        &consensus_sig, 
        &KeyContext::GameState
    ).expect("Should handle wrong context");
    assert!(!is_invalid, "Wrong context should fail verification");
}

/// Test that timing attacks are mitigated
#[tokio::test]
async fn test_timing_attack_mitigation() {
    let mut keystore = SecureKeystore::new().expect("Should create keystore");
    let message = b"Timing attack test message";
    let signature = keystore.sign(message).expect("Should create signature");
    let public_key = keystore.export_public_key();
    
    let num_trials = 100;
    let mut valid_times = Vec::new();
    let mut invalid_times = Vec::new();
    
    // Measure timing for valid signature verification
    for _ in 0..num_trials {
        let start = std::time::Instant::now();
        let _result = SecureKeystore::verify_signature(message, &signature, &public_key)
            .expect("Should verify signature");
        valid_times.push(start.elapsed());
    }
    
    // Measure timing for invalid signature verification
    let mut invalid_signature = signature.clone();
    invalid_signature.0[0] = invalid_signature.0[0].wrapping_add(1);
    
    for _ in 0..num_trials {
        let start = std::time::Instant::now();
        let _result = SecureKeystore::verify_signature(message, &invalid_signature, &public_key)
            .expect("Should handle invalid signature");
        invalid_times.push(start.elapsed());
    }
    
    // Calculate average times
    let avg_valid_time = valid_times.iter().sum::<std::time::Duration>() / valid_times.len() as u32;
    let avg_invalid_time = invalid_times.iter().sum::<std::time::Duration>() / invalid_times.len() as u32;
    
    // Times should be reasonably similar (within 2x factor)
    let ratio = if avg_valid_time > avg_invalid_time {
        avg_valid_time.as_nanos() as f64 / avg_invalid_time.as_nanos() as f64
    } else {
        avg_invalid_time.as_nanos() as f64 / avg_valid_time.as_nanos() as f64
    };
    
    // This is a basic timing analysis - Ed25519 verification should have similar timing
    // for valid and invalid signatures since it's designed to be constant-time
    assert!(ratio < 3.0, 
            "Timing difference too large: valid={:?}, invalid={:?}, ratio={}",
            avg_valid_time, avg_invalid_time, ratio);
}

/// Test that memory is securely handled (no sensitive data leaks)
#[tokio::test]
async fn test_secure_memory_handling() {
    let mut keystore = SecureKeystore::new().expect("Should create keystore");
    
    // Test that sensitive operations don't leave traces in memory
    // This is a basic test - in practice, you'd need specialized tools to check memory
    
    // Generate some sensitive data
    let sensitive_message = b"Very sensitive cryptographic data that should be cleared";
    let signature = keystore.sign(sensitive_message).expect("Should create signature");
    let nonce = keystore.generate_commitment_nonce();
    let random_bytes = keystore.generate_random_bytes(64);
    
    // Use the data
    let public_key = keystore.export_public_key();
    let is_valid = SecureKeystore::verify_signature(sensitive_message, &signature, &public_key)
        .expect("Should verify signature");
    assert!(is_valid, "Signature should verify");
    
    // At this point, ideally sensitive data should be zeroized
    // The SecureKeystore implements Drop to zeroize sensitive data
    drop(keystore);
    
    // Test that new instances don't accidentally reuse old memory
    let new_keystore = SecureKeystore::new().expect("Should create new keystore");
    let new_public_key = new_keystore.export_public_key();
    
    assert_ne!(public_key, new_public_key, 
               "New keystore should not reuse old key material");
}

/// Test replay attack prevention
#[tokio::test]
async fn test_replay_attack_prevention() {
    let mut keystore = SecureKeystore::new().expect("Should create keystore");
    let message = b"Message that should not be replayable";
    
    // Create timestamped signature
    let signature = keystore.sign_with_context(message, KeyContext::Consensus)
        .expect("Should create timestamped signature");
    
    // Signature should verify initially
    let is_valid = SecureKeystore::verify_secure_signature(message, &signature, &KeyContext::Consensus)
        .expect("Should verify fresh signature");
    assert!(is_valid, "Fresh signature should verify");
    
    // Create signature with old timestamp (simulating replay)
    let old_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs() - 7200; // 2 hours old
    
    let mut old_signature = signature.clone();
    old_signature.timestamp = old_time;
    
    // Old signature should fail verification
    let is_invalid = SecureKeystore::verify_secure_signature(message, &old_signature, &KeyContext::Consensus)
        .expect("Should handle old timestamp");
    assert!(!is_invalid, "Old signature should fail due to timestamp");
    
    // Future signature should also fail (prevents pre-computation attacks)
    let future_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs() + 7200; // 2 hours in future
    
    let mut future_signature = signature.clone();
    future_signature.timestamp = future_time;
    
    let is_invalid = SecureKeystore::verify_secure_signature(message, &future_signature, &KeyContext::Consensus)
        .expect("Should handle future timestamp");
    assert!(!is_invalid, "Future signature should fail due to timestamp");
}

/// Test that concurrent operations maintain security
#[tokio::test]
async fn test_concurrent_security_operations() {
    use tokio::task;
    
    let num_threads = 10;
    let operations_per_thread = 100;
    
    let handles: Vec<_> = (0..num_threads).map(|thread_id| {
        task::spawn(async move {
            let mut keystore = SecureKeystore::new().expect("Should create keystore");
            let mut all_signatures_valid = true;
            let mut all_randoms_unique = true;
            
            let mut thread_randoms = Vec::new();
            
            for i in 0..operations_per_thread {
                let message = format!("Thread {} operation {}", thread_id, i);
                
                // Perform cryptographic operations
                let signature = keystore.sign(message.as_bytes()).expect("Should sign");
                let random_bytes = keystore.generate_random_bytes(32);
                let nonce = keystore.generate_commitment_nonce();
                
                // Verify signature
                let public_key = keystore.export_public_key();
                let is_valid = SecureKeystore::verify_signature(message.as_bytes(), &signature, &public_key)
                    .expect("Should verify");
                
                if !is_valid {
                    all_signatures_valid = false;
                }
                
                // Check random uniqueness within thread
                if thread_randoms.contains(&random_bytes) {
                    all_randoms_unique = false;
                }
                thread_randoms.push(random_bytes);
            }
            
            (thread_id, all_signatures_valid, all_randoms_unique, thread_randoms)
        })
    }).collect();
    
    // Collect results
    let mut all_thread_randoms = Vec::new();
    for handle in handles {
        let (thread_id, sigs_valid, randoms_unique, thread_randoms) = handle.await.expect("Should complete");
        
        assert!(sigs_valid, "All signatures should be valid in thread {}", thread_id);
        assert!(randoms_unique, "All randoms should be unique in thread {}", thread_id);
        
        all_thread_randoms.extend(thread_randoms);
    }
    
    // Check that randoms are unique across all threads
    let mut unique_randoms = std::collections::HashSet::new();
    for random in &all_thread_randoms {
        assert!(unique_randoms.insert(random.clone()), 
                "Random value should be unique across all threads");
    }
    
    assert_eq!(unique_randoms.len(), all_thread_randoms.len(),
               "All random values across all threads should be unique");
}